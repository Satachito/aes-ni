//	April 2021 Written by Satoru Ogura.
//	https://www.intel.com/content/dam/doc/white-paper/advanced-encryption-standard-new-instructions-set-paper.pdf
//	https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf
//	test vectors were taken from http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

#include	<iostream>
#include	<string>
#include	<vector>
using namespace std;

#include	"Hex.h"
#include	"AES-NI.h"
#include	<unistd.h>

typedef	unsigned char	UI1;

ALIGN16 UI1
AES128_TEST_KEY[] = {
	0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
	0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
};
ALIGN16 UI1
AES192_TEST_KEY[] = {
	0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,
	0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
	0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b
};
ALIGN16 UI1
AES256_TEST_KEY[] = {
	0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,
	0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
	0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,
	0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4
};
ALIGN16 UI1
AES_TEST_VECTOR[]	= {
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F
};

/*****************************************************************************/

UI1
plain[] = {
	0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
,	0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
,	0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef
,	0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};

void
ECB_128() {

	auto	Nr = 10;

	ALIGN16	__m128i
	encryptKey[ Nr + 1 ];
	AES_128_Key_Expansion( (__m128i*)AES128_TEST_KEY, encryptKey );

	UI1
	encoded[ 64 ];
	AES_ECB_encrypto(
		plain
	,	encoded
	,	4
	,	encryptKey
	,	Nr
	);
	UI1
	expected[] = {
		0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
	,	0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf
	,	0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88
	,	0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
	};
	for ( auto _ = 0; _ < 64; _++ ) if ( encoded[ _ ] != expected[ _ ] ) throw "Hay differencia.";

	ALIGN16	__m128i
	decryptKey[ Nr + 1 ];
	AES_decrypto_key_128( encryptKey, decryptKey );
	UI1
	decoded[ 64 ];
	AES_ECB_decrypto(
		encoded
	,	decoded
	,	4
	,	decryptKey
	,	Nr
	);
	for ( auto _ = 0; _ < 64; _++ ) if ( plain[ _ ] != decoded[ _ ] ) throw "Hay differencia.";
}
void
CBC_128() {

	auto	Nr = 10;

	ALIGN16	__m128i
	encryptKey[ Nr + 1 ];
	AES_128_Key_Expansion( (__m128i*)AES128_TEST_KEY, encryptKey );

	UI1
	encoded[ 64 ];

	{	ALIGN16 __m128i
//		IV	= _mm_set_epi8( 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f );
		IV	= _mm_set_epi8( 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 );
		AES_CBC_encrypto(
			plain
		,	encoded
		,	&IV
		,	4
		,	encryptKey
		,	Nr
		);
		UI1
		expected[] = {
			0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46, 0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d
		,	0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee, 0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2
		,	0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b, 0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16
		,	0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09, 0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
		};
		for ( auto _ = 0; _ < 64; _++ ) if ( encoded[ _ ] != expected[ _ ] ) throw "Hay differencia.";
	}
	{	ALIGN16	__m128i
		decryptKey[ Nr + 1 ];
		AES_decrypto_key_128( encryptKey, decryptKey );
		ALIGN16 __m128i
//		IV	= _mm_set_epi8( 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f );
		IV	= _mm_set_epi8( 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 );
		UI1
		decoded[ 64 ];
		AES_CBC_decrypto(
			encoded
		,	decoded
		,	&IV
		,	4
		,	decryptKey
		,	Nr
		);
		for ( auto _ = 0; _ < 64; _++ ) if ( plain[ _ ] != decoded[ _ ] ) throw "Hay differencia.";
	}
}
void
CTR_128() {

	auto	Nr = 10;

	ALIGN16	__m128i
	cryptKey[ Nr + 1 ];
	AES_128_Key_Expansion( (__m128i*)AES128_TEST_KEY, cryptKey );

	UI1
	encoded[ 64 ];

	{	ALIGN16 __m128i
//		COUNTER	= _mm_set_epi8( 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff );
		COUNTER	= _mm_set_epi8( 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0 );

		AES_CTR_crypto(
			plain
		,	encoded
		,	&COUNTER
		,	4
		,	cryptKey
		,	10
		);
		UI1
		expected[] = {
			0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26, 0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce
		,	0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff, 0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff
		,	0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e, 0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab
		,	0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1, 0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee
		};
		for ( auto _ = 0; _ < 64; _++ ) if ( encoded[ _ ] != expected[ _ ] ) {
			cerr << EncodeHexLF16( (UI1*)&COUNTER, 16 ) << endl;
			cerr << EncodeHexLF16( encoded, 64 ) << endl;
			throw "Hay differencia en encode.";
		}
	}

	{	ALIGN16 __m128i
//		COUNTER	= _mm_set_epi8( 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff );
		COUNTER	= _mm_set_epi8( 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0 );

		UI1
		decoded[ 64 ];
		AES_CTR_crypto(
			encoded
		,	decoded
		,	&COUNTER
		,	4
		,	cryptKey
		,	10
		);
		for ( auto _ = 0; _ < 64; _++ ) if ( plain[ _ ] != decoded[ _ ] ) throw "Hay differencia en decode.";
	}
}
void
CTR_128_INTEL() {

	auto	Nr = 10;

	UI1		PLAINTEXT[ 64 ];
	auto	i = 0;
	for ( i = 0; i < 64 / 16 / 2; i++ ) {
		for ( auto j = 0; j < 2; j++ ) {
			_mm_storeu_si128(
				&((__m128i*)PLAINTEXT)[i*2+j]
			,	((__m128i*)AES_TEST_VECTOR)[j]
			);
		}
	}
	auto	j = i * 2;
	for ( ; j < 64 / 16; j++ ) {
		_mm_storeu_si128(
			&((__m128i*)PLAINTEXT)[j]
		,	((__m128i*)AES_TEST_VECTOR)[j%4]
		);
	}
	if ( 64 % 16 ) {
		_mm_storeu_si128(
			&((__m128i*)PLAINTEXT)[j]
		,	((__m128i*)AES_TEST_VECTOR)[j%4]
		);
	}

//	cout << "The PLAINTEXT:\n";
//	for ( auto i = 0; i< 64 / 16; i++ ) cout << '\t' << EncodeHex( &PLAINTEXT[ i * 16 ], 16 ) << endl;
//	cout << endl;

	UI1
	key[] = {
		0x7E,0x24,0x06,0x78,0x17,0xFA,0xE0,0xD7,
		0x43,0xD6,0xCE,0x1F,0x32,0x53,0x91,0x63
	};
	ALIGN16	__m128i
	cryptKey[ Nr + 1 ];
	AES_128_Key_Expansion( (__m128i*)key, cryptKey );
//	for ( auto _ = 0; _ < Nr + 1; _++ ) cout << EncodeHex( (UI1*)&cryptKey[ _ ], 16 ) << endl;

	UI1
	encoded[ 64 ];
	
	{	ALIGN16 __m128i
//		COUNTER	= _mm_set_epi8( 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59, 0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 );
		COUNTER	= _mm_set_epi8( 0x01, 0x00, 0x00, 0x00, 0x0b, 0xd9, 0x48, 0xda, 0x59, 0x3b, 0x54, 0xc0, 0xdb, 0xb6, 0x6c, 0x00 );

		AES_CTR_crypto(
			PLAINTEXT
		,	encoded
		,	&COUNTER
		,	4
		,	cryptKey
		,	10
		);
	//	cerr << EncodeHex( encoded, 64 ) << endl;
		UI1
		expected[] = {
			0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9, 0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88
		,	0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8, 0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28
		,	0xd9, 0x13, 0x07, 0x7a, 0xe5, 0x4e, 0x62, 0xab, 0xf2, 0x82, 0xbd, 0x01, 0x72, 0x21, 0xb3, 0x62
		,	0x34, 0xbb, 0x81, 0xe9, 0x8b, 0xa3, 0xbe, 0x57, 0x75, 0x2a, 0x55, 0x7b, 0x2c, 0xe5, 0x77, 0x31
		};
		for ( auto _ = 0; _ < 64; _++ ) if ( encoded[ _ ] != expected[ _ ] ) throw "Hay differencia en encoded.";
	}
	
	{	ALIGN16 __m128i
//		COUNTER	= _mm_set_epi8( 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59, 0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 );
		COUNTER	= _mm_set_epi8( 0x01, 0x00, 0x00, 0x00, 0x0b, 0xd9, 0x48, 0xda, 0x59, 0x3b, 0x54, 0xc0, 0xdb, 0xb6, 0x6c, 0x00 );

		UI1
		decoded[ 64 ];
		AES_CTR_crypto(
			encoded
		,	decoded
		,	&COUNTER
		,	4
		,	cryptKey
		,	10
		);
//	cerr << EncodeHex( PLAINTEXT, 64 ) << endl;
//	cerr << EncodeHex( decoded, 64 ) << endl;
		for ( auto _ = 0; _ < 64; _++ ) if ( PLAINTEXT[ _ ] != decoded[ _ ] ) throw "Hay differencia en decoded.";
	}
}


int
main( int argc, char** argv ) {
	try {
		if ( !Check_CPU_support_AES() ) throw "Cpu does not support AES instruction set. Bailing out.";
		ECB_128();
		cerr << "ECB 128 OK" << endl;
		CBC_128();
		cerr << "CBC 128 OK" << endl;
		CTR_128();
		cerr << "CTR 128 OK" << endl;
		CTR_128_INTEL();
		cerr << "CTR 128 INTEL OK" << endl;
	} catch ( const char* _ ) { cerr << _ << endl; }
}

